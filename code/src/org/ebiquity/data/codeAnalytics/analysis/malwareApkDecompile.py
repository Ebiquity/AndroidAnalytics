#!/usr/bin/python
# -*- coding: utf-8 -*-
'''
Created on October 4, 2015
@author: Prajit Kumar Das
Usage: python malwareApkDecompile.py
'''

import os
import sys
import platform
import shutil
import subprocess
from bs4 import BeautifulSoup as Soup
import time
import installApkTool as apktool
import socket
import json
from collections import defaultdict

def isPathPresent(path):
	if os.path.exists(path):
		return True
	return False

def createFolder(path):
	if os.path.exists(path):
		return
	# 	shutil.rmtree(path)
	os.makedirs(path)

def isAPKPermissionsAlreadyInTable(dbHandle,pkgName):
	cursor = dbHandle.cursor()
	sqlStatement = "SELECT COUNT(a.app_id) FROM `appperm` a, `appdata` b WHERE a.app_id = b.id AND b.app_pkg_name = '"+pkgName+"';"
	try:
		cursor.execute(sqlStatement)
		queryOutput = cursor.fetchall()
		for row in queryOutput:
			if row[0] > 0:
				return True
			return False
	except:
		print "Unexpected error:", sys.exc_info()[0]
		raise

def extractPackageInfo(manifestFile):
	XMLFileHandler = open(manifestFile).read()
	soup = Soup(XMLFileHandler)
	
	# Extract package name used by the app and store in the DB
	for message in soup.findAll('manifest'):
		return message.get('package')

def moverecursively(source_folder, destination_folder):
    basename = os.path.basename(source_folder)
    dest_dir = os.path.join(destination_folder, basename)
    if not os.path.exists(dest_dir):
        shutil.move(source_folder, destination_folder)
    else:
        dst_path = os.path.join(destination_folder, basename)
        for root, dirs, files in os.walk(source_folder):
            for item in files:
                src_path = os.path.join(root, item)
                if os.path.exists(dst_file):
                    os.remove(dst_file)
                shutil.move(src_path, dst_path)
            for item in dirs:
                src_path = os.path.join(root, item)
                moverecursively(src_path, dst_path)

'''
	http://stackoverflow.com/questions/1557351/python-delete-non-empty-dir
	The standard library includes shutil.rmtree for this. By default,
	
	shutil.rmtree(path)  # errors if dir not empty
	will give OSError: [Errno 66] Directory not empty: <your/path>.
	
	You can delete the directory and its contents anyway by ignoring the error:
	
	shutil.rmtree(role_fs_path, ignore_errors=True)
	You can perform more sophisticated error handling by also passing onerrror=<some function(function, path, excinfo)>.
'''
def runAnalysis(inpath,outPath,currentDirectory,separator,malwareAppDataFile):
	#	Run analysis
	# dbHandle = databaseHandler.dbConnectionCheck()

	filenames = []
	for root, subFolders, subFolderFilenames in os.walk(inpath):
		for file in subFolderFilenames:
			filenames.append(root+separator+os.path.basename(file))

	appPermDict = defaultdict(list)

	for apk in filenames:
		apkFileName = os.path.basename(apk)
		tempPackageName = apkFileName.replace(".apk", "")
		outputFolder = outPath+tempPackageName

		try:
		 	subprocess.call(["apktool", "d", "-f", apk, "-o", outputFolder])#, shell=True)
			osInfo = platform.system()
			if osInfo == 'Windows':
				manifestFile = outputFolder+"\\AndroidManifest.xml"
			elif osInfo == 'Linux':
				manifestFile = outputFolder+"/AndroidManifest.xml"

			packageName = extractPackageInfo(manifestFile)

			renamedManifestFile = outPath+packageName+".xml"
			destFolderName = outPath+packageName

			os.rename(manifestFile, renamedManifestFile)
			moverecursively(outputFolder, destFolderName)
			# shutil.rmtree(outputFolder, ignore_errors=True)
			# Remove the apk file once processed
			#os.remove(apk)
			permissionDict, permissionsList = extractPermissionsInfo(packageName,renamedManifestFile)

			appPermDict[packageName].append(permissionsList)
			appPermDict['permissionDict'].append(permissionDict)
			print "Decompilation process for: "+packageName+" is complete, moving on to next app."

			# with open(malwareAppDataFile, 'w') as fp:
			# 	json.dump(appPermDict, fp, indent=4)
		except:
			print "Skipping: "+apkFileName
			appPermDict[apkFileName].append(['Error'])

	with open(malwareAppDataFile, 'w') as fp:
		json.dump(appPermDict, fp, indent=4)

def extractManifestFiles(malwareAppDataFile):
	currentDirectory = os.getcwd()

	# Detect operating system and takes actions accordingly
	osInfo = platform.system()
	if osInfo == 'Windows':
		decommpileOutputDirectory = currentDirectory+"\\data\\"
		appsFolder = currentDirectory+"\\androidMalwareSamples\\"
		separator = "\\"
	elif osInfo == 'Linux':
		decommpileOutputDirectory = currentDirectory+"/data/"
		appsFolder = currentDirectory+"/androidMalwareSamples/"
		separator = "/"
	else:
		print 'The current os not supported at the moment.'

	if isPathPresent(appsFolder):
		createFolder(decommpileOutputDirectory)
		runAnalysis(appsFolder,decommpileOutputDirectory,currentDirectory,separator,malwareAppDataFile)
	else:
		print 'The androidMalwareSamples folder doesn\'t exist. Create one and download apks to it and then run this script again.'

def verifyIfPermissionIsInTable(permissionName):
	dbHandle = databaseHandler.dbConnectionCheck()
	cursor = dbHandle.cursor()
	sqlStatement = "SELECT count(*) FROM `permissions` WHERE `name` = '"+permissionName+"';"
	try:
		cursor.execute(sqlStatement)
		if cursor.rowcount > 0:
			return True
		return False
	except:
		print "Unexpected error:", sys.exc_info()[0]
		raise

def extractCustomPermissions(soup):
	permissionsList = []
	permissionDict = {}
	for message in soup.findAll('permission'):
		permissionsAttributes = dict(message.attrs)
		permissionName = permissionsAttributes['android:name']
		if 'android:protectionLevel' in permissionsAttributes:
			permissionProtectionLevel = permissionsAttributes['android:protectionLevel']
		else:
			'''
				android:protectionLevel: Characterizes the potential risk implied in the permission and indicates the procedure the system should follow when determining 
				whether or not to grant the permission to an application requesting it. The value can be set to one of the following strings:
				"normal": 				The default value. A lower-risk permission that gives requesting applications access to isolated application-level features, with minimal risk 
										to other applications, the system, or the user. The system automatically grants this type of permission to a requesting application at installation, 
										without asking for the user's explicit approval (though the user always has the option to review these permissions before installing).
				"dangerous":			A higher-risk permission that would give a requesting application access to private user data or control over the device that can negatively impact the user. 
										Because this type of permission introduces potential risk, the system may not automatically grant it to the requesting application. 
										For example, any dangerous permissions requested by an application may be displayed to the user and require confirmation before proceeding, 
										or some other approach may be taken to avoid the user automatically allowing the use of such facilities.
				"signature":			A permission that the system grants only if the requesting application is signed with the same certificate as the application that declared the 
										permission. If the certificates match, the system automatically grants the permission without notifying the user or asking for the user's explicit approval.
				"signatureOrSystem":	A permission that the system grants only to applications that are in the Android system image or that are signed with the same certificate as the 
										application that declared the permission. Please avoid using this option, as the signature protection level should be sufficient for most needs and works 
										regardless of exactly where applications are installed. The "signatureOrSystem" permission is used for certain special situations where multiple vendors 
										have applications built into a system image and need to share specific features explicitly because they are being built together.
			'''
			permissionProtectionLevel = 'normal'
		# if not verifyIfPermissionIsInTable(permissionName):
		# 	sqlStatement = "INSERT INTO `permissions`(`name`,`protection_level`) VALUES ('"+permissionName+"','"+permissionProtectionLevel+"');"
		# 	dbHandle = databaseHandler.dbConnectionCheck()
		# 	databaseHandler.dbManipulateData(dbHandle, sqlStatement)
		permissionDict[permissionName] = permissionProtectionLevel
		permissionsList.append(permissionName)

	return permissionDict, permissionsList

def getAppId(dbHandle,sqlStatement,pkgName):
	cursor = dbHandle.cursor()
	try:
		cursor.execute(sqlStatement)
		if cursor.rowcount > 0:
			queryOutput = cursor.fetchall()
			for row in queryOutput:
				appId = row[0]
		else:
			print "Probably the app data for: "+pkgName+" has not been collected because we could not find that app in the database:", sys.exc_info()[0]
			return -1
	except:
		print "Unexpected error:", sys.exc_info()[0]
		raise
	return appId

def getPermissionId(dbHandle,sqlStatement,permissionName):
	cursor = dbHandle.cursor()
	try:
		cursor.execute(sqlStatement)
		if cursor.rowcount > 0:
			queryOutput = cursor.fetchall()
			for row in queryOutput:
				permissionId = row[0]
		else:
			sqlStatement = "INSERT INTO `permissions`(`name`) VALUES ('"+permissionName+"');"
			permissionId = databaseHandler.dbManipulateData(dbHandle, sqlStatement)
	except:
		print "Unexpected error:", sys.exc_info()[0]
		raise
	return permissionId

# Update "perm_extracted" column to mark permissions for app have been extracted
def updatePermExtracted(dbHandle, pkgName):
	sqlStatement = "UPDATE `appurls` SET `perm_extracted`=1 WHERE `app_pkg_name`='"+pkgName+"';"
	databaseHandler.dbManipulateData(dbHandle, sqlStatement)

def extractPermissionsInfo(pkgName,renamedManifestFile):
	permissionsList = []

	XMLFileHandler = open(renamedManifestFile).read()
	soup = Soup(XMLFileHandler)

	# Extract permissions created by the app and store in the DB
	permissionDict, permissionsList = extractCustomPermissions(soup)
	
	# Extract permissions used by the app and store in the DB
	for message in soup.findAll('uses-permission'):
		permissionsList.append(message.get('android:name'))
		# dbHandle = databaseHandler.dbConnectionCheck()

		# # See if the permission is in the table if not insert it and get its id
		# sqlStatementPermName = "SELECT id FROM `permissions` WHERE `name` = '"+permissionName+"';"
		# permissionId = getPermissionId(dbHandle,sqlStatementPermName,permissionName)
		
		# # Find the App's Id in the DB
		# # Assumption is that the crawlURL has already extracted all information about the app and the same is in the appdata table
		# # If that is not true this step will fail and we will move on to the next app
		# sqlStatementAppPkgName = "SELECT id FROM `appdata` WHERE `app_pkg_name` = '"+pkgName+"';"
		# appId = getAppId(dbHandle,sqlStatementAppPkgName,pkgName)
		# if appId > 0:
		# 	# Insert the App_Id and corresponding Perm_Id in to the DB
		# 	sqlStatement = "INSERT INTO `appperm`(`app_id`,`perm_id`) VALUES ("+str(appId)+","+str(permissionId)+");"
		# 	databaseHandler.dbManipulateData(dbHandle, sqlStatement)
		# 	# The permissions have been inserted so now we can update the appurls table stating the same
		# 	updatePermExtracted(dbHandle, pkgName)
		# else:
		# 	print "Moving on to the next app"

	return permissionDict, permissionsList

def getPath():
    if socket.gethostname() == 'eclipse':
        return '/tank/usersc/'+getpass.getuser()+'/'

    currentDirectory = os.getcwd()

    # Detect operating system and take actions accordingly
    osInfo = platform.system()
    if osInfo == 'Windows':
        return currentDirectory+"\\"
    elif osInfo == 'Linux':
        return currentDirectory+"/"
    else:
        print 'The current os not supported at the moment.'
        return None

def preProcess():
	ticks = time.time()
	uniformString = str(ticks).replace('.', '')
	malwareAppDataFile = getPath()+'malwareAppData'+uniformString+'.json'
	text_file = open(malwareAppDataFile, 'w')
	text_file.write('')
	text_file.close()
	return malwareAppDataFile

def doTask():
	startTime = time.time()
	extractManifestFiles(preProcess())
	executionTime = str((time.time()-startTime)*1000)
	print "Execution time was: "+executionTime+" ms"

def main(argv):
	if len(sys.argv) == 2:
		if sys.argv[1] == '-f':
			apktool.run(True)
			doTask()
		else:
			sys.stderr.write('Usage: python malwareApkDecompile.py forceInstallApkToolflag(-f)\n')
			sys.exit(1)
	elif len(sys.argv) == 1:
		apktool.run(False)
		doTask()
	else:
		sys.stderr.write('Usage: python malwareApkDecompile.py forceInstallApkToolflag(-f)\n')
		sys.exit(1)

if __name__ == "__main__":
	sys.exit(main(sys.argv))
